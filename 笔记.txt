Eureka属于CAP里面的Ap分支
某一个时刻，某个微服务不可用了，不会立即被清楚，依旧会对该服务的信息进行保存

为什么会产生Eureka自我保护机制
为了防止EurekaClient可以正常运行，但是在网络不通的情况下，EurekaServer不会立刻把Client清楚

在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任务服务实力，设计哲学就是宁可保留错误的无福注册信息，也不盲目注销任何可能健康的服务实例

ZooKeeper注册的节点应该是临时的

Concul:
使用go语言实现的。
是一套开源的分布式服务发现饿配置管理系统，提供了微服务系统中的服务治理、配置中心、控制总线等功能，这些功能中的每一个都开源根据需要单独使用，也可以一起使用以构建全方位的服务网络，种植Consul提供了一种完整的
服务网格，总之Consul提供了一种完整的无福网格解决方案。
有点。包括基于raft协议，比较简介，健康检查。

Spring Cloud Consul具有如下特性：
    Service Discovery:

    Health Checking:

    KV Store: 键值对存储

    Secure Service Communication:

    Multi Datacenter:

什么是CAP:
C:Consistency(强一致性)
A:Availability(可用性)
P:Partition tolerance(分区容错性)
CAP理论关注粒度是数据，而不是整体系统设计的

CAP理论核心是:一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，
因此根据CAP原理将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类：
CA-单点集群。满足一致性，可用性的系统，通常在可拓展性上不太强大
CP-满足一致性。分区容忍性的系统，通常性能不是特别高。
AP-满足可用性，分区容忍性的系统，通常可能对一致性要求低一点

Zookeeper和consul是CP


Ribbon
Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端 负载均衡的工具
简单的说，Ribbon是Netflix发布的开源项目，主要功能室提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置比如连接超时，重试等等。简单的说，就是在配置文件中列出Load Balancer后面所有的机器，
Ribbon会自动的帮助你基于某种规则(如简单轮训，随即连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。

LB负载均衡是什么
简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用)
常见的负载均衡软件有Nginx, LVS等

Ribbon本地负载均衡客户端 VS Nginx服务器端负载均衡区别
Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后又nginx实现转发请求，负载均衡由服务端实现的

Ribbon本地负载均衡，在调用微服务接口的时候，会在注册中心上湖区注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
OpenFeign

Feign是一个声明式WebService客户端，使用Feign能让编写Web Service客户端更加简单
他的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器，Spring Cloud对Feign进行了封装，使其支持Spring MVC标注注解和GttpMessageConverters。
Feigh可以于Eureka和Ribbon组合使用以负载均衡
只需要创建一个接口并在接口上添加注解即可

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多历来不可避免的会调用失败，比如超时，异常，Hystrix能够保证在一个以来出问题的情况下，不回导致整体服务失败，
避免及联故障，以提高分布式系统的弹性。

"断路器"本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似于保险丝熔断），想调用方返回一个复合预期的，可处理的备选响应(FallBack），而不是长时间的等待或者抛出调用方法无法处理的异常，这样就保证了服务调用方
的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延、乃至雪崩。


我们对自己配置过的热部署方式对java代码的改动明显，但对@HystrixCommand内属性的修改建议重启微服务

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
熔断机制概述
熔断机制是对应雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。
当检测到该节点微服务调用响应正常后，恢复调用链路。

在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务调用的状况。
当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制，熔断机制的注解是@HystrixCommand

总结：
closed -> open -> half open

涉及到断路器的三个重要参数：快照时间窗，请求总数阈值，错误百分比阈值
1、快照时间窗：断路器确实是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒

2、请求总数阈值：在快照时间窗内，必须满足请求总数阈值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。

3、错误百分比阈值：当请求总数在快照时间窗内超过了阈值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的百分比，在默认设定50%阈值的等情况下，这时候就会将断路器打开

默认10秒内超过20个请求次数
默认10秒50%的失败
到达以上阈值，断路器将会开启
当开启的时候，所有请求都不会进行转发
一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个成功，

1。再有请求调用的时候，将不会调用侏罗纪，而是直接调用降级的fallback。通过断路器，实现了自动发现错误并将降级逻辑切换为侏罗纪，减少响应延迟的效果

2。原来的主逻辑要如何恢复呢？
对于这一问题，hystrix也为我们实现了自动恢复功能。
当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑。
当休眠时间窗到期，断路器将进入半开状态，是将一次请求到原来的侏罗纪上，如果此次请求正常返回，那么断路器将继续闭合，
主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗口会重新计时

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SpringCloud Gateway是Spring Cloud的一个全新项目，基于Spring 5.0+SpringBoot 2.0 和Project Reactor等技术开发的网管，它旨在为微服务架构提供一种简单有效的统一的API路由管理方式

SpringCloud Gateway作为Spring Cloud生态系统中的网管，目标是替代Zuul, 在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用Zuul 1.x非
Reactor模式的老版本，而为了提升网管的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。

Spring Cloud Gateway的目标提供统一的路由方式且基于Filtr链的方式提供了网管基本的功能，例如：安全，监控/指标，和限流。

Getway具有如下特性：

基于Spring Framework 5, Project Reactor 和Spring Boot 2.0 进行构建
动态路由：能够匹配任何请求属性
可以对路由制定Predicate(断言)和Filter（过滤器）
集成Hystrix的断路器功能
集成Spring Cloud服务发现功能
易于便携的Predicate（断言）和Filter（过滤器）
请求限流功能
支持路径重写

Geteway三大概念：
路由：路由是构建网管的基本模块，他由ID,目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由

断言：参考的是java8的java.util.function.Predicate
开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数），如果请求与断言相匹配则进行路由

Filter（过滤）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。

filter生命周期 2个，pre和post

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Config
 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息，才能运行，所以一套集中式的，动态的配置管理设施是必不可少的

 Spring Cloud提供了ConfigServer来解决这个问题，我们每一个微服务自己呆着一个applicatino.yml

 是什么？
 SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。

 能干嘛？
 集中管理配置文件
 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/bate/release
 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会像配置中心统一拉去配置自己的信息。
 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置。
 将配置信息以REST接口的形势暴漏

application.yml是用户级的资源配置项
bootstrap.yml是系统级的，优先级更高

Spring Cloud会创建一个Bootstrap Context, 作为Spring应用的Application Context的父上下文，初始化的时候，Bootstrap Context负责从外部源家在配置属性并解析，这两个上下文共享一个从外部获取的Environment

Bootstrap属性有高优先级，默认情况下，他们不会被本地配置覆盖。Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。
要将Client模块下的application.yml文件改为bootstrap.yml这是很关键的

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Bus
什么是总线
在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个公用的消息主题，并让系统中所有微服务实例都链接上来，由于该主题中产生的消息会被所有实例坚挺和消息，所以称他为消息总线。在总线上的各个实例，
都可以方便的广播一些需要让其他连接在该主题上的实例都知道的消息。

基本原理
ConfigClient实例都监听MQ中同一个topic(默认是SpringCloudBus)。当一个服务刷新数据的时候，他会把这个信息放入到Topic中，这样其他监听同一个Topic的服务就能得到通知，然后去更新自身的配置。

设计思想：
1）利用消息总线出发一个客户端/bus/refresh，而刷新所有客户端的配置
2）利用消息总线出发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置

2更加合理：
原因是
1打破了微服务的指责单一性，因为微服务本身是业务模块，他本不应该承贷配置刷新的指责。
1破坏了微服务各个节点的对等性
且有一定的局限性，例如，微服务在迁移的时候，它的网络地址常常会发生辩护啊，此时如果想要做到自动刷新，那就会增加更多的配置

指定具体某一个实力生效而不是全部
公式：http://localhost:配置中心的端口号/actuator/bus-refresh/{destination}

/bus/refresh 请求不再发送到具体的服务实例上，而是发给config server并通过destination参数类指定需要更新配置的服务或实例

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Stream解决的问题
MQ(消息中间件)
在系统中的不同平台使用了不同的消息队列，stream就是为了解决我们不需要再关注MQ的具体细节，我们只需要使用一种适配绑定的方式，自动的给我们在各种MQ内切换

是什么？
屏蔽底层消息中间件的差异，降低切换成本，统一消息的变成模型。

通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离

Stream中的消息通信方式遵循了发布-订阅模式 ----> Topic进行发布主题

Binder: 很烦遍的连接中间件，屏蔽差异
Channel: 通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置
Source和Sink：简单理解就是输入输出，生产者和消费者


重复消费问题：
比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息。
那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。
这是我们就可以使用Stream中的消息分组来解决

注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次
不同组是可以全面消费的(重复消费)

解决方法就是对于同一个服务放进同一个组中。
自定义配置分组，
自定义分为同一个组，

分组同时可以解决，消息重复消费和消息持久化的问题。

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Sleuth：
为什么出现这个技术？解决了什么问题？
在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。

Sleuth提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin

Trace: 类似于树结构的Span集合，表示一条调用链路，存在唯一标示
span:表示调用链路来源，通俗的理解span就是一次请求信息

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Nacos:

关于AP和CP：
一般来说，如果不需要存储服务级别的信息且服务实力是通过nacos-client注册，并能够保持心跳上报，就可以选择ap模式，当前主流的服务如Spring cloud和Dubbo服务，都适用于AP模式，AP模式为了服务的可能性而
减弱了一致性，因此Ap模式值支持注册临时实例

如果需要在服务级别编辑或者存储配置信息，那么CP是必须的，K8S服务和DNS服务则适用于CP模式
CP模式下则支持注册持久化实力，此时则是以Raft协议为集群运行模式，改模式下注册实例之前必须先注册服务，如果服务不存在，则会返回错误。

Nacos Config:
    Nacos同springcloud config 一样，在项目初始化的时候，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动。 springboot中配置文件的家在是存在优先顺序的,bootstrap优先级高于application

    公式:
        ${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos,config.file-extension}
    在我们的项目中：
        nacos-config-client-dev.yml

    自带config+bus功能

    2）nacos分类配置
    是什么？
        类似于java里面的package名和类名
        最外层的namespace是可以用于区分部署环境的，Group和DataID逻辑上区分两个目标对象
    默认情况：
        namespace=public, Group=DEFAULT_GROUP,默认Cluster是DEFAULT

    Nacos默认的命名空间是public，Namespace主要用来实现隔离
    比如说我们现在又三个环境：开发，测试，生产环境，我们iu可以创建三个Namespace,不同的Namespace之间是隔离的

    Group默认是DEFAULT_GROUP,Group可以把不同的微服务划分到同一个分组里面去

    Service就是微服务；一个service可以包含多个Cluster(集群),Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。
    比如说为了容灾，将Service微服务分别部署在了杭州机房和广州机房，
    这时就可以给杭州机房的Service微服务起一个集群名称(HZ)
    给广州机房的Service微服务起一个集群名称(GZ),还可以尽量让同一个机房的微服务互相调用，以提升性能

    最后Instance,就是微服务的实例

    DataID方案：
    1）指定spring.profile.active和配置文件的DataID来使不同环境下读取不同的配置文件
    2）默认空间+默认分组+新建dev和test两个DataID

    GROUP方案：
    新建不同的group

    Namespace方案：
    新建不同的namespace


Nacos集群和持久化














